help.search('mann kendall')
help(cor.test)
help.search('kendall')
library(Stats)
library(stats)
?cor.test
?wilcos
?wilcox
??wilcox
?wilcox.test
?html
??html
?normcdf
??gaussian
??norm
pnorm(-2.5)
pnorm(2.5)
1/pnorm(-2.5)
1/pnorm(2.5)
GreenAmp <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	return(e,p,ir,ip)#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	return(e,p,ir,ip)#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	plot(e,type="l")#
	lines(p,col="blue")#
	lines(ir)#
	lines(ir,col="red")#
	lines(ip,col="green")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=2)#
	plot(p,col="blue")#
	plot(e,type="l")#
	lines(ir)#
	lines(ir,col="red")#
	lines(ip,col="green")#
}
GreenAmpt(1,10,0,precip)
?par
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(1,2))#
	plot(p,col="blue")#
	plot(e,type="l")#
	lines(ir)#
	lines(ir,col="red")#
	lines(ip,col="green")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue")#
	plot(e,type="l")#
	lines(ir)#
	lines(ir,col="red")#
	lines(ip,col="green")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
abline(h=2)
?plot
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
	lines(ip,type='s',col="green")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,col="green")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	lines(Ia,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			e[t] <- p[t] - ir[t]#
		} else {#
			ir[t] <- p[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min(ip[t]-p[t],Pa)			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min(ip[t]-p[t],Pa)			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min({ip[t]-p[t]},Pa)			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min({ip[t]-p[t]},Pa[t])			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			kk <- ip[t]-p[t]#
			ipond[t] <- min(kk,Pa[t])			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min(ip[t]-p[t],Pa[t])			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
?min
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
#			ipond[t] <- min({ip[t]-p[t]},Pa[t])			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min({ip[t]-p[t]},Pa[t])#
			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ipond <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min({ip[t]-p[t]},Pa[t])#
			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	plot(e,type="s")#
	lines(ir,type='s')#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
GreenAmpt <- function(K,S,I0,p){#
	# crea vectores temporales de las variables de estado#
	n <- length(p)#
	Ia <- rep(0,n)#
	Pa <- rep(0,n)#
	ir <- rep(0,n)#
	ipond <- rep(0,n)#
	ip <- rep(0,n)#
	e <- rep(0,n)#
	# inicializa la infiltración acumulada#
	Ia[1]=I0#
	# itera a lo largo del evento, actualizando las variables#
	# de estado según las reglas anteriores#
	for (t in 1:n) {#
		ip[t] <- K + S/Ia[t]#
		if (p[t]>=ip[t]) {#
			ir[t] <- ip[t]#
			ipond[t] <- 0#
			e[t] <- p[t] - ir[t]#
		} else {#
			ipond[t] <- min({ip[t]-p[t]},Pa[t])#
			ir[t] <- p[t] + ipond[t]#
			e[t] <- 0#
		}#
		Ia[t+1] <- Ia[t] + ir[t]#
		Pa[t+1] <- Pa[t] + e[t] - ipond[t]#
	}#
	#return(e,ir,ip)#
	par(mfrow=c(2,1))#
	plot(p,col="blue",type='s')#
	lines(ip,type='s',col="green")#
	#lines(Ia,type='s',col="brown")#
	lines(Pa,type='s',col="brown")#
	abline(h=2,lty='dashed')#
	plot(e,type="s")#
	lines(ir,type='s',col="red")#
}#
#
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,1,2,0,0,1,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,1,2,0,0,7,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
precip <- c(2,1,3,5,5,4,3,1,0,1,0,0,0,0,0,0,0,0,0,1,2,0,0,4,0,0,0,0,0,0,0)#
GreenAmpt(1,10,0,precip)
library(nlme)
?gls
ls()
qnorm(0.5)
qnorm(0.025)
qnorm(1-0.025)
qnorm(1-0.05)
qnorm(0.005)
qnorm(1-0.005)
1-0.001
1-0.01
1-0.005
1-0.025
1-0.05
?qnorm
pnorm(-1)
qnorm(0.1)
qnorm(0.05)
library(evd)
?evd
help(evd)
?qgpd
library(RKML)
?RKML
?kmlPoints
1:3
1:3,12
1:3, 12
?strptime
t <- strptime('26.01.2011 13:43:00',format="%d.%m.%y %H:%M:%S")
t <- strptime('26.01.11 13:43:00',format="%d.%m.%y %H:%M:%S")
as.POSIXlt(t)
as.POSIXct(t)
class(as.POSIXct(t))
as.POSICxt(Sys.time())
as.POSIXct(Sys.time())
t
class(t)
as.numeric(t)
?pnorm
pnorm(2.33)
1/pnorm(2.33)
(1-pnorm(2.33))
1/(1-pnorm(2.33))
library(chron)
?chron
julian(22,2,2011)
julian(22,2,2011,origin=l(1,1,2011))
julian(22,2,2011,origin=c(1,1,2011))
julian(1,1,2011)
julian(1,1,2000)
x<-seq(10957,(10957+3500),)
x<-seq(10957,(10957+3500),1)
x
month.day.year(x)
# Dependences#
library(ncdf4)#
library(snowfall)#
#
# Escalas temporales del analisis#
sca <- 12
spi.nc <- nc_open(paste('./spi',sca,'log-Logistic.nc',sep=''))#
sp3.nc <- nc_open(paste('./spi',sca,'PearsonIII.nc',sep=''))#
tho.nc <- nc_open(paste('./spei',sca,'Thornthwaite.nc',sep=''))#
pen.nc <- nc_open(paste('./spei',sca,'Penman.nc',sep=''))#
har.nc <- nc_open(paste('./spei',sca,'Hargreaves.nc',sep=''))
spi.nc <- nc_open(paste('./spi',sca,'log-Logistic.nc',sep=''))
paste('./spi',sca,'log-Logistic.nc',sep='')
?choose
choose(1,2)
choose(2,2)
choose(3,2)
choose(5,2)
library(sp)
library(maptools)
library(gstat)
?aggregate
aggregate
cls()
clear()
library(SPEI)
data(tampa)
summary(tampa)
?tampa
?spei
?thornthwaite
bal <- read.table('balances.csv',sep=';',head=T)
bal
summary(bal)
spei(bal,12)
spei_12 <- spei(bal,12)
summary(spei_12)
write.table(spei_12,'spei_12.txt')
spei(bal[,1],3)
tampa$bal <- thornthwaite(tampa$Tave,27.947/57.2957795)
tampa$pet <- thornthwaite(tampa$Tave,27.947/57.2957795)
names(tampa)
tampa$bal <- tampa$Pre-tampa$pet
tampa$bal
hist(tampa$bal)
hist(tampa$pet)
hist(tampa$Pre)
tampa$spei12 <- spei(tampa$bal,12)
tampa$spei12
spi(tampa$Pre,12)
tampa$spi_12 <- spi(tampa$Pre,12)
plot(tampa$spi_12)
tampa$spi_12 <- as.numeric(spi(tampa$Pre,12))
tampa$spi_12 <- as.numeric(spei(tampa$Pre,12,distribution='PearsonIII'))
tampa$spi_12 <- spei(tampa$Pre,12,distribution='PearsonIII')
hist(tampa$spi_12)
tampa$spi_12
